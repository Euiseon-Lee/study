class Solution {
    public int[] solution(int[] arr, int k) {
        /**
         * ✅ 문제 요약
         *  - 주어진 정수 k가 홀수인지 짝수인지에 따라, 배열 arr의 각 요소를 다음과 같이 변환
         *    1. k가 홀수 → arr[i] * k
         *    2. k가 짝수 → arr[i] + k
         *
         * 🔁 기존 코드 흐름
         *  - k의 홀짝 여부를 먼저 판단하여 분기 (if-else)
         *  - 각 분기 내부에서 동일한 for문을 사용하여 요소 변환 수행
         *  - answer 배열은 arr와 동일한 길이로 초기화
         *
         * 💡 개선 포인트
         *  - 현재 구조는 분기와 연산의 결합이 명확해 가독성이 뛰어남
         *  - 반복 루프 구조가 두 번 중복되므로, 조건만 분리해 루프를 단일화할 수 있음
         *    → 코드 길이 단축, 중복 제거 효과 있음
         *
         * ⚙️ 성능 분석
         *  - 시간복잡도: O(n), n = arr.length
         *  - 공간복잡도: O(n), 새로운 배열 answer 생성
         *  - 테스트 결과:
         *    → 이중 분기 구조와 루프 단일화 구조 모두 테스트 10~11번 대형 케이스에서 8ms 내외
         *    → 실행 시간에서 유의미한 차이 없음 (JVM 최적화 영향)
         *
         * 🧠 JVM 최적화 관점 정리
         *  - k % 2 == 1 같은 단순 조건은 JVM이 루프 시작 전에 상수로 치환함 (Loop Invariant Code Motion)
         *  - 삼항 연산자도 JIT 컴파일러가 branch prediction 기반으로 최적화 처리
         *  - 루프 내부 조건 분기는 **연산이 가볍고 조건이 고정된 경우** 성능 차이를 유발하지 않음
         *
         * ⚖️ 실무 판단 기준
         *  - "성능 최적화"는 구조보다 **복잡한 연산, 메모리 접근, 외부 I/O**에 의해 결정되는 경우가 많음
         *  - 조건 분기가 간단하고 루프가 단순할 경우 → 루프 안 조건식 허용
         *  - 조건이 복잡하거나 연산이 무겁다면 → 루프 외부에서 분기 처리
         *  - JMH, VisualVM 등으로 실제 병목을 확인하고 결정하는 것이 가장 안전함
         *
         * 🛠 실무 활용도
         *  - 정책에 따라 가중치 처리 방식이 달라지는 데이터 후처리, 할인 계산, 스코어 보정 등에 사용
         *  - 내부 로직은 단순하지만, 루프 구조 최적화 판단 능력은 실무 성숙도와 직결
         *
         * 🧠 현재 구현 수준 평가
         *  - 루프 구조 중복을 줄이는 판단, 성능 최적화 가능성에 대한 고민이 명확함
         *  - JVM의 최적화 방식까지 고려한 설계 사고가 녹아 있음
         *  - 실무 구조 사고 기준 Level 3에서 Level 4 진입 감각 보유
         */
        int[] answer = new int[arr.length];
        boolean isOdd = k % 2 == 1;
        for (int i = 0; i < arr.length; i++) {
            answer[i] = isOdd ? arr[i] * k : arr[i] + k;
        }
        return answer;
    }
}

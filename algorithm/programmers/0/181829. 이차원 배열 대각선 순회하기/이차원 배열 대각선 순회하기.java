class Solution {
    public int solution(int[][] board, int k) {
        /**
         * ✅ 문제 요약
         *  - 정수 k와 2차원 정수 배열 board가 주어질 때,
         *    i + j ≤ k를 만족하는 모든 (i, j) 위치의 board[i][j] 값을 더해 반환
         *
         * 🔁 코드 로직 요약
         *  - i는 0부터 board.length - 1 또는 k까지 순회 (행 경계 제한)
         *  - j는 0부터 (k - i) 또는 board[0].length - 1까지 순회 (열 경계 제한)
         *  - 위 조건을 만족하는 모든 board[i][j] 값을 누적 합산
         *  - 불필요한 i, j 루프 회피를 위해 lengthX, lengthY, end 등으로 경계값 미리 계산
         *
         * 💡 구조적 개선 포인트
         *  - 삼항연산자를 사용한 i, j 루프 범위 제한 → 불필요한 반복 방지
         *  - 반복문 내부 조건문 없이 i+j ≤ k를 만족하는 영역만 탐색 → 분기 제거로 성능 향상
         *  - 직관적으로 i + j ≤ k를 좌상단 삼각형 영역으로 인식하고 이를 좌표 조합으로 분해
         *
         * ⚙️ 성능 분석
         *  - 시간복잡도: 최악의 경우 약 O(n²), 하지만 i + j ≤ k 조건으로 영역이 제한됨
         *    → 탐색 범위는 최대 (k+1)(k+2)/2개 → 삼각형 수열 구조
         *  - 공간복잡도: O(1) → 누적합만 저장
         *  - 테스트 결과: 전 케이스에서 0.01 ~ 0.05ms 사이로 매우 빠르게 처리됨
         *
         * 🧠 실무 감각 포인트
         *  - 2차원 인덱스 조합 조건을 사전에 분해하고, 반복문 조건을 분기 없이 설계하는 구조는
         *    실무에서 자주 활용되는 고급 기법 (예: 이미지 처리, 거리 기반 탐색)
         *  - 반복 루프 안에서 조건을 검사하지 않고, **루프 조건 자체로 제어한 설계**가 특히 뛰어남
         *  - 이 구조는 BFS, DP 테이블 최적화 영역에서도 자주 사용됨
         *
         * 🛠 실무 활용도
         *  - 2차원 좌표 기반 탐색, 지역합 계산, 마스킹, 조건부 집계 등에서 유용
         *  - 예: 게임 맵 탐색, 영역 제한 가중치 합계, 그리드 상의 조건 집계 등
         *
         * 🧠 현재 구현 수준 평가
         *  - 반복 경계 최적화와 조건 제거, 메모리 최소화까지 모두 반영된 고급 구조
         *  - 코드 가독성과 성능 사이의 밸런스가 우수
         *  - 실무 구조 사고 기준 Level 4 초입 진입 → 2차원 조건 분기 최적화 능력 확보
         */        
        int answer = 0;
        int lengthX = k > board.length - 1 ? board.length - 1 : k;
        int lengthY = board[0].length - 1;
        for (int i = 0; i <= lengthX; i++) {
            int end = (k - i) > lengthY ? lengthY : (k - i);
            for (int j = 0; j <= end; j++) {
                answer += board[i][j];
            }   
        }
        return answer;
    }
}

class Solution {
    public int solution(int[] arr1, int[] arr2) {
        /**
         * ✅ 배열 대소 비교 규칙
         * 1️⃣ 길이가 다르면 → 길이 긴 쪽이 크다
         * 2️⃣ 길이가 같으면 → 각 배열의 합을 비교
         *     - 합이 크면 큰 배열
         *     - 합이 같으면 동일한 배열
         *
         * 🔁 구현 방식
         * - 길이 비교: arr1.length - arr2.length > 0 → arr1이 김 → 1 반환
         * - 길이가 같을 경우:
         *     - (arr1[i] - arr2[i]) 누적으로 두 배열 합의 차이 계산
         *     - 누적값이 0이면 동일, 양수면 arr1 우세, 음수면 arr2 우세
         *
         * 💡 차별점
         * - 합 비교를 위해 두 배열 요소를 sum1, sum2로 누적하지 않고,
         *   `answer += (arr1[i] - arr2[i])` 한 줄로 처리하여 메모리 사용을 줄임
         * - 길이 비교 조건을 먼저 분기함으로써 시간 절약
         *
         * ⚙️ 성능
         * - 시간복잡도: O(n), 단 한 번의 루프
         * - 공간복잡도: O(1), 합만 비교하므로 추가 공간 사용 없음
         * - 테스트 평균 실행 시간: 약 0.02 ~ 0.04ms → 최적 수준
         *
         * 🛠 실무 활용성
         * - 명시적 분기 구조: 조건이 우선순위에 따라 분리되어 있어 유지보수 용이
         * - 불필요한 연산 제거: 두 배열의 합을 따로 계산하지 않아 간결함
         * - (주의) answer에 차이를 누적하는 방식은 문제 조건이 '합'일 때만 유효하며,
         *   일반적 원소 간 비교 문제에는 사용하지 않아야 함
         */
        if (arr1.length != arr2.length) {
            return arr1.length - arr2.length > 0 ? 1 : -1;
        }
        int answer = 0;
        for(int i = 0; i < arr1.length; i++) {
            answer += (arr1[i] - arr2[i]);
        }
        return answer == 0 ? answer : (answer > 0) ? 1 : -1;
    }
}

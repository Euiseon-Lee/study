class Solution {
    public int solution(int a, int b) {
        /**
         * ✅ 문제 요약
         *  - 두 정수 a, b의 홀짝 여부에 따라 결과 계산 방식이 달라지는 조건 분기 문제
         *    1. 둘 다 홀수 → 제곱합 반환
         *    2. 둘 다 짝수 → 차이의 절댓값 반환
         *    3. 하나는 홀수, 하나는 짝수 → 두 수의 합 * 2 반환
         *
         * 🔁 기존 코드 흐름
         *  - a와 b의 홀수 여부를 boolean 변수 isOddA, isOddB로 구분
         *  - 조건 분기 3개로 각각 처리: (홀, 홀) → (짝, 짝) → (혼합)
         *  - 반환값은 각각 Math.pow, Math.abs, 덧셈/곱셈 연산 사용
         *
         * 💡 개선 포인트
         *  - boolean 변수를 사전에 분리한 덕분에 조건문의 가독성이 매우 높음
         *  - 성능상 병목은 없지만, 수학적 연산 표현은 연산 우선순위를 고려해 괄호 사용은 필수
         *  - 실무에서는 이와 같은 분기 로직을 별도 메서드로 분리해 읽기 쉽게 구성하는 경우도 많음
         *
         * ⚙️ 성능 분석
         *  - 조건 1회 분기 + 간단한 산술 연산만 수행 → O(1) 시간복잡도
         *  - 테스트 결과 모든 케이스 0.01 ~ 0.05ms로 안정적이며 지연 없음
         *  - 연산 자체가 매우 단순하기 때문에 메모리 사용량 또한 낮고 고정됨
         *
         * 🧠 조건 분기 처리 팁
         *  - boolean 분리 → 조건문 간소화 + 중복 피하기
         *  - 3가지 이상 case 분기 시에는 if → else if → else 구조로 직관화 가능
         *  - 성능 영향은 없지만 로직 가독성과 유지보수성이 좋아짐
         *
         * 🛠 실무 활용도
         *  - 사용자 입력, 로그 분석, 규칙 기반 정책 처리 등에서 조건 분기 + 계산 로직은 매우 자주 등장
         *  - 실무에서는 enum + 전략 패턴으로 추상화하는 구조로 발전 가능
         *
         * 🧠 현재 구현 수준 평가
         *  - boolean 조건 분리를 통한 조건 해석 능력 명확함
         *  - 조건 분기 구조를 최소화하면서 각 분기마다 의미 있는 반환 처리 가능
         *  - 실무 구조 사고 기준 Level 3 중상 수준으로, **가독성과 조건 처리 균형감 뛰어남**
         */
        boolean isOddA = a % 2 == 1;
        boolean isOddB = b % 2 == 1;
        if (isOddA && isOddB) return (a * a) + (b * b);
        if (!isOddA && !isOddB) return Math.abs(a - b);
        return 2 * (a + b);
    }
}

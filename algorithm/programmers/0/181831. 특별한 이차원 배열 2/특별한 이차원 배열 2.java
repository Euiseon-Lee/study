class Solution {
    public int solution(int[][] arr) {
        /**
         * ✅ 문제 요약
         *  - 주어진 정사각형 2차원 배열 arr이 대칭 행렬인지 검사
         *    (즉, arr[i][j] == arr[j][i]가 모든 원소 쌍에서 성립해야 함)
         *  - 조건을 만족하면 1, 아니면 0을 반환
         *
         * 🔁 코드 로직
         *  - 행 인덱스 i와 열 인덱스 j를 모두 순회하며
         *    arr[i][j] != arr[j][i]가 발견되면 즉시 0 반환
         *  - 모든 검사를 통과하면 1 반환
         *  - 불필요한 변수 없이, 조건 불만족 시 조기 탈출 구조로 성능 최적화
         *
         * 💡 개선 포인트 (논리 구조 측면)
         *  - 현재 코드는 모든 (i, j) 쌍을 검사하므로 조건 검사에 완전함
         *  - 중복 검사 영역(i > j 또는 i < j)을 줄이면 성능 개선 가능
         *    → 하지만 입력 크기(최대 100 x 100)에서는 실질적 이득 없음
         *
         * ⚙️ 성능 분석
         *  - 시간복잡도: O(n²), 공간복잡도: O(1)
         *  - 테스트 결과: 평균 0.01 ~ 0.36ms → 전 구간에서 매우 안정적
         *  - 비교 연산은 가볍고, 조건문 브랜치도 단순하여 JVM 최적화 효과 큼
         *
         * 🧠 절반 루프 구조와의 비교
         *  - `(i > j)` 영역만 검사하면 비교 횟수를 반으로 줄일 수 있음
         *    (대칭성 특성상 i == j는 자명하고, i < j는 i > j와 동일한 정보)
         *  - 그러나 성능 차이는 거의 없음:
         *    * 입력 크기가 작고,
         *    * 연산이 매우 가벼우며,
         *    * JVM의 JIT 최적화가 적용됨 (loop unrolling, branch prediction)
         *
         * ⚖️ 실무 판단 기준
         *  - 조건의 명확성과 신뢰성을 우선할 경우 → 전체 순회(i x j) 선호
         *  - 데이터가 매우 크거나 고성능 실시간 처리일 경우 → 절반 검사 고려
         *  - 성능 병목이 의심되는 경우 JMH, VisualVM 등으로 측정 후 판단
         *
         * 🧠 현재 구현 수준 평가
         *  - 대칭 조건 인식 및 조기 반환 구조를 정확히 구현
         *  - 반복 구조 설계 및 최적화 가능성에 대한 고민까지 반영됨
         *  - 실무 구조 사고 기준 Level 3 최상위 ~ Level 4 진입 수준
         *    (조건 충족 여부 + 최적화 의식 + 정확한 판단 근거 확보)
         */
        int answer = 1;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                if (arr[i][j] != arr[j][i]) return 0;
            }
        }
        return answer;
    }
}

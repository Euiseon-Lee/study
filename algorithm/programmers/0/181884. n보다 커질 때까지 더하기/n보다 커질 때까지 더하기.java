class Solution {
    public int solution(int[] numbers, int n) {
        /**
         * 📌 누적합이 주어진 값 n을 초과할 때까지 더한 합 반환
         *
         * ✅ 핵심 로직
         * - 배열 `numbers`를 앞에서부터 순회하며 누적합을 계산
         * - 누적합이 `n`을 초과하는 순간 즉시 반복 종료 (`break`)
         * - 누적합을 반환
         *
         * ✅ 성능 분석
         * - 시간복잡도: O(k), k는 `누적합 > n`이 되는 최초 위치
         *   → 평균적으로 전체를 다 순회하지 않아 빠르게 종료됨
         * - 공간복잡도: O(1), 별도 자료구조 사용 없음
         * - 테스트 기준 실행 시간: 0.01 ~ 0.03ms (매우 우수)
         *
         * ✅ 실무 활용도
         * - 조건 충족 시 조기 종료되는 누적 합 구조는 실무에서 자주 등장
         *   (예: 일정 금액 초과 시 결제 차단, 로그 발생 임계값 감지 등)
         * - 반복 중단 기준을 `누적 조건`으로 설정하면 불필요한 반복을 줄일 수 있음
         *
         * ✅ 보완 포인트
         * - 숫자 overflow 가능성이 있는 경우 `long` 타입 누적합을 고려해야 함
         * - 사전에 정렬이 보장된 경우 이진 탐색(BS)을 통해 더 최적화된 접근도 가능
         *
         * ✅ 참고
         * - `for-each` 구조도 가능하나 인덱스를 활용한 반복이 중단 처리에 더 명확함
         */
        int answer = 0;
        for (int i = 0; i < numbers.length; i++) {
            answer += numbers[i];
            if (answer > n) break;
        }
        return answer;
    }
}

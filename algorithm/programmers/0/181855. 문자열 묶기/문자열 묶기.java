class Solution {
    public int solution(String[] strArr) {
        /**
         * ✅ 문자열 길이 기반 최대 빈도 그룹 계산
         *
         * 📌 문제 조건
         * - 문자열 배열 strArr 내 각 문자열의 길이는 1~30 사이
         * - 길이가 같은 문자열끼리 그룹화하여, 가장 많은 그룹의 크기를 반환
         *
         * 🔢 핵심 로직
         * 1️⃣ 길이 빈도 집계 배열 생성: int[] arr = new int[31]
         * 2️⃣ 문자열마다 길이 측정 → 해당 인덱스의 값 증가
         * 3️⃣ 증가 시 동시에 최대 빈도값(answer)을 갱신하여 반복 종료 후 바로 반환
         *
         * 🚀 성능 분석
         * - 시간 복잡도: O(N) (N = strArr.length)
         * - 공간 복잡도: O(1) (길이 범위 고정 → 배열 크기 상수)
         * - 테스트 기준: 최대 8.48ms로 대규모 입력도 효율적으로 처리
         *
         * 💡 실무 활용도
         * - 길이나 등급, 시간대 등 '고정 범위 정수형 분포' 집계에 최적
         * - 해시맵보다 메모리 접근 비용이 낮고, 정렬 없이도 최대 빈도 파악 가능
         * - 로그 분석, 응답 시간 분포 집계, 단어 빈도 분석 등에서 활용 가능
         *
         * 🛠 보완 포인트
         * - 현재 문제 조건에서는 최적 구현. 다만 길이 범위가 변동 가능할 경우 Map<Integer, Integer> 사용 고려 필요
         * - `stream()`이나 `Collectors.groupingBy()` 기반 접근은 가독성은 높지만, 성능 측면에선 불리하므로 본 방식이 실무에서 더 효율적
         * - `arr[0]`은 절대 사용되지 않으므로 주석으로 명시하거나 `arr[1] ~ arr[30]`만 도는 구조도 명확성을 줄 수 있음
         *
         * 🧠 실력 레벨 진단
         * - 본 코드는 실무형 사고 Level 4 문제 해결 기준에 부합
         * - 자료구조 선택 능력(배열 vs 맵), 고정 범위 판단, 반복 중 최대값 추적 등 실무형 판단력이 명확히 반영됨
         * - 다음 성장 포인트: '동적 범위 데이터' 상황에서 효율적인 자료구조와 로직 구조를 유연하게 전환하는 훈련
         */
        int answer = 0;
        int[] arr = new int[31];
        for (String str : strArr) {
            int length = str.length();
            arr[length]++;
            answer = Math.max(answer, arr[length]);
        }
        return answer;
    }
}

class Solution {
    public int[] solution(int[] arr) {
        /**
         * 📌 조건에 따라 배열 원소 변경 – 짝수/홀수 + 임계값 조건
         *
         * ✅ 핵심 로직
         * - 각 원소에 대해 아래의 규칙으로 변환하여 반환:
         *   1. 50 이상이면서 짝수 → 절반으로 나눈다
         *   2. 50 미만이면서 홀수 → 두 배로 만든다
         *   3. 그 외는 그대로 둔다
         *
         * ✅ 성능 분석
         * - 시간복잡도: O(n) – 배열 한 번 순회
         * - 공간복잡도: O(1) – 입력 배열을 직접 수정 (in-place)
         * - 실행 성능 매우 우수 (대형 테스트도 13ms 수준으로 통과)
         *
         * ✅ 실무 활용도
         * - 정제된 조건 기반의 배열 필터링/가공 작업에서 자주 활용되는 패턴
         * - 데이터를 "상태 기반으로 분기 처리"하는 로직은 센서 데이터 후처리, 이미지 픽셀 처리 등에서 자주 사용됨
         *
         * ✅ 보완 포인트
         * - 가독성을 위해 다중 삼항 연산자 대신 명시적 if-else 블록을 사용하는 것도 고려 가능
         *   → 추후 유지보수 시 조건 누락이나 수정이 용이해짐
         * - 입력 배열을 직접 수정하는 구조이므로, 원본 보존이 필요한 경우 복사본을 사용하는 것이 바람직
         *
         * ✅ 리팩토링 예시 (가독성 우선):
         * if (arr[i] >= 50 && arr[i] % 2 == 0) {
         *     arr[i] /= 2;
         * } else if (arr[i] < 50 && arr[i] % 2 == 1) {
         *     arr[i] *= 2;
         * }
         *
         */
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (arr[i] >= 50 && arr[i] % 2 == 0) ? arr[i] / 2 : (arr[i] < 50 && arr[i] % 2 == 1) ? arr[i] * 2 : arr[i];
        }
        return arr;
    }
}
